# **Self‑Modifying Malware Reversing Labs (Lab04)**

This directory contains advanced reversing labs focused on **self‑modifying malware techniques observed in real-world native Linux binaries**.

Unlike anti‑debugging, these labs target a deeper problem:

> **The code you analyze is not the code that executes.**

Lab04 trains the analyst to survive environments where:

* instructions rewrite themselves
* control flow mutates at runtime
* payloads do not exist statically
* strings, logic, and data are staged into memory
* patching is easy — but *understanding is hard*

All labs are solved using **manual reasoning, runtime memory inspection, and proof via execution**, primarily with **radare2**.


---

## **Core Philosophy**

Self‑modifying malware exists to destroy assumptions:

* static disassembly is incomplete
* strings lie
* control flow graphs rot
* patching ≠ comprehension

These labs enforce one discipline:

> **Trust runtime state over static truth.**

---

## **Lab Structure**

```
lab_01_runtime_decryption
lab_02_Self-Patching_Control_Flow(Runtime Code Rewrite)
lab_03_Staged_Self-Decryption_with_Opaque_Predicate_&_Debugger_Trap
lab_04_Payload_Discovery_&_Runtime_Analysis_Notes
```

Each lab introduces a stronger form of **runtime mutation**, forcing the analyst to adapt tools, mindset, and verification strategy.

---

## **Lab 04‑1 — Runtime Decryption (Execution‑Time Reveal)**

Introduces the simplest but most dangerous concept:

> **The real code does not exist until execution.**

### Focus

* Encrypted instruction regions
* Runtime XOR / arithmetic decoding
* Memory permission changes (`RWX` transitions)
* Why static strings and functions disappear
* Locating the decryption window in execution

Goal: prove *when* and *where* plaintext code materializes.

---

## **Lab 04‑2 — Self‑Patching Control Flow (Runtime Code Rewrite)**

Moves from data mutation to **instruction mutation**.

The binary actively rewrites its own branches and jumps.

### Focus

* In‑place opcode rewriting
* Conditional logic destruction
* Fake branches vs real branches
* Patch‑induced deception
* Verifying control flow using runtime state

Goal: distinguish **apparent control flow** from **actual control flow**.

---

## **Lab 04‑3 — Staged Self‑Decryption with Opaque Predicate & Debugger Trap**

Introduces **multi‑stage payload construction** with intentional analyst traps.

The program:

* decrypts data in stages
* hides payloads behind opaque predicates
* presents fake success paths
* crashes or lies under tracing

### Focus

* Opaque predicates that always evaluate the same way
* Debugger‑sensitive execution paths
* Register‑assembled payload construction
* SIMD (`xmm`) assisted data synthesis
* ABI‑level argument tracing (`rdi`, `rsi`, `rdx`)

Goal: **prove payload existence and location**, not just bypass logic.

---

## **Lab 04‑4 — Payload Discovery & Runtime Analysis (Capstone)**

Final lab: **the payload is never statically visible**.

No readable strings.
No obvious buffers.
No direct jumps.

The only proof is runtime memory state.

### Focus

* Calling convention reconstruction
* Differentiating format strings from payloads
* Register‑sourced pointers
* Memory‑backed execution truth
* Why patching success can still mean analytical failure

Goal: extract and characterize the real payload **without symbolic help**.

---

## **Analysis Model Progression**

```
static trust
→ decrypted code trust
→ rewritten instruction trust
→ control‑flow illusion trust
→ payload‑pointer truth
→ runtime memory supremacy
```

Each lab removes another static assumption.

---

## **Conventions**

Each lab contains:

* `notes.md` with proof‑based reasoning
* runtime memory observations
* patched vs unpatched behavior comparison
* radare2‑only workflow

No emulators.
No deobfuscation frameworks.
No symbolic execution.

---

## **What This Series Is (and Is Not)**

✔ Real malware self‑modification patterns\
✔ Runtime execution truth\
✔ Memory‑first analysis mindset\
✔ ABI‑level reasoning\
✔ Payload discovery discipline

✘ Exploitation\
✘ Shellcoding (next series)\
✘ Obfuscation theory\
✘ Automated reversing

---

## **Outcome**

After completing Lab04, the analyst can:

* Detect self‑modifying behavior early
* Stop trusting static disassembly
* Track runtime memory evolution
* Identify real payload storage
* Prove execution truth under mutation
* Transition cleanly into shellcode analysis

Self‑modifying malware does not hide.

It **moves**.

---

> Static analysis shows possibilities.
> Runtime analysis shows reality.
