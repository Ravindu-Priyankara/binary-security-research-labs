#define _GNU_SOURCE
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>

/* ===============================
   Encrypted Payload (Stage 3)
   =============================== */
static uint8_t payload[] = {
    0x9a,0xaf,0x88,0xd1,0xe3,0x91,0xc2,0x11,
    0x44,0x2a,0x99,0x7f,0x00
};

/* ===============================
   Key Material (Stage 1)
   =============================== */
static uint8_t keyblob[] = {
    0x31,0x7e,0x19,0xa4,0x55,0x8c
};

/* ===============================
   Anti-Debug: corruption, not crash
   =============================== */
int is_debugged() {
    FILE *f = fopen("/proc/self/status", "r");
    if (!f) return 0;

    char buf[256];
    int traced = 0;
    while (fgets(buf, sizeof(buf), f)) {
        if (!strncmp(buf, "TracerPid:", 10)) {
            traced = atoi(buf + 10) != 0;
            break;
        }
    }
    fclose(f);
    return traced;
}

/* ===============================
   Rolling XOR Decrypt
   =============================== */
void decrypt(uint8_t *b, size_t len, uint8_t k) {
    for (size_t i = 0; i < len; i++) {
        b[i] ^= k;
        k = (k + 0x3d) ^ (i * 7);
    }
}

/* ===============================
   Opaque Predicate
   =============================== */
int opaque(uint8_t *b) {
    return ((b[1] + b[3]) ^ b[5]) == 0xA9;
}

/* ===============================
   Self-Patching Logic
   Flips a conditional jump
   =============================== */
void self_patch() {
    uintptr_t page = (uintptr_t)&self_patch & ~0xfff;

    mprotect((void*)page, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC);

    /* Patch target: JE â†’ JNE */
    uint8_t *patch = (uint8_t*)((uintptr_t)&opaque + 0x2);
    *patch ^= 0x01;

    __builtin___clear_cache((char*)page, (char*)(page+0x1000));
}

/* ===============================
   Main Loader
   =============================== */
int main() {

    uint8_t k = 0xAA;

    /* Anti-debug alters key material */
    if (is_debugged()) {
        k ^= 0x55;
        keyblob[2] ^= 0x33;
    }

    self_patch();

    decrypt(keyblob, sizeof(keyblob), k);

    if (!opaque(keyblob)) {
        puts("Fake execution path.");
        return 0;
    }

    decrypt(payload, sizeof(payload)-1, keyblob[1]);

    printf("[+] Payload unlocked: %s\n", payload);

    /* NEXT LABS: mmap + shellcode exec here */

    return 0;
}
