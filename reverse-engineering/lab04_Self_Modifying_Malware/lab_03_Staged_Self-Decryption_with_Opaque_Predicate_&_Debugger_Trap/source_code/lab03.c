#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <string.h>
#define decrypt a1b2
#define is_debugged c3d4

// Stage 1: Initial key bytes (Initial XOR Key: 0xAA)
// Decrypts to reveal the derivation key for Stage 2
static uint8_t stage1[] = {
    0xf8, 0x90, 0x6e, 0xda, 0x22, 0xa5, 0x09, 0x9e, 
    0x6b, 0x21, 0x2d, 0xaf
};

// Stage 2: Verification bytes (Initial XOR Key: stage1[0] ^ stage1[3])
// Decrypts to satisfy the opaque_check: (b[2] ^ b[5]) == 0x99
static uint8_t stage2[] = {
    0x2c, 0x47, 0xf6, 0x0a, 0x47, 0x4c, 0x47, 0x0b
};

// Stage 3: Encrypted "Success! Lab Done." (Initial XOR Key: stage2[1])
static uint8_t stage3[] = {
    0x7b, 0x5a, 0x53, 0x42, 0x45, 0x56, 0x56, 0x01, 
    0x7c, 0x08, 0x3d, 0x45, 0x47, 0x07, 0x24, 0x4b, 
    0x54, 0x40, 0x00
};

void delayed_crash() {
    printf("[-] Debugger detected! Memory corrupted.\n");
    sleep(1);
    *(volatile int *)0 = 0xdead; // Segfault
}

int is_debugged() {
    FILE *f = fopen("/proc/self/status", "r");
    if (!f) return 0;

    char line[256];
    int result = 0;
    while (fgets(line, sizeof(line), f)) {
        if (!strncmp(line, "TracerPid:", 10)) {
            result = (atoi(line + 10) != 0);
            break;
        }
    }
    fclose(f);
    return result;
}

void decrypt(uint8_t *b, size_t len, uint8_t k) {
    for (size_t i = 0; i < len; i++) {
        b[i] ^= k;
        // The Rolling Key Logic
        k = (k + 0x3d) ^ (i * 7);
    }
}

int opaque_check(uint8_t *b) {
    // Condition to pass: (stage2[2] ^ stage2[5]) == 0x99
    return ((b[2] ^ b[5]) == 0x99);
}

int main() {
    // 1. Anti-Debug Check
    if (is_debugged()) {
        delayed_crash();
    }

    // 2. Stage 1 Decryption
    decrypt(stage1, sizeof(stage1), 0xAA);
    
    // 3. Derive key for Stage 2
    uint8_t key2 = stage1[0] ^ stage1[3];
    decrypt(stage2, sizeof(stage2), key2);

    // 4. Opaque Logic Check
    if (!opaque_check(stage2)) {
        puts("Fake execution path - Logic failure.");
        return 1;
    }

    // 5. Stage 3 Decryption (Depends on Stage 2 being correct)
    printf("[+] Opaque check passed. Decrypting main payload...\n");
    decrypt(stage3, sizeof(stage3) - 1, stage2[1]);

    // 6. Final Result
    // In real malware, this is where the shellcode is moved to RWX memory and executed.
    // For this lab, we print the string to verify success.
    printf("[+] Final Payload: %s\n", (char*)stage3);

    return 0;
}