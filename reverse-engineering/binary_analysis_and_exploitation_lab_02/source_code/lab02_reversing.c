/*
 * lab02_reversing.c
 * Purpose: small, self-contained reversing exercise.
 * Build :
 *   gcc lab02_reversing.c -o lab02_hard -O3 -fomit-frame-pointer -s -fPIE -pie -fno-stack-protector -Wl,-z,relro,-z,now
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

/*****************
 * Helper types
 *****************/
typedef int (*handler_t)(const char *);

/* Simple XOR-based transform used in one function */
static void xor_transform(char *buf, size_t n, unsigned char key) {
    for (size_t i = 0; i < n; ++i) buf[i] ^= key;
}

/* Print a short banner */
static void banner(void) {
    puts("=== LAB02 - reverse me ===");
}

/* A few small functions to create a call graph */
static int check_magic(const char *s) {
    /* returns 1 if s contains the magic substring "R3V" */
    if (!s) return 0;
    return (strstr(s, "R3V") != NULL);
}

static int compute_hash(const char *s) {
    /* Simple non-cryptographic rolling hash used for flow decisions */
    unsigned int h = 5381;
    for (const unsigned char *p = (const unsigned char *)s; *p; ++p) {
        h = ((h << 5) + h) + *p; /* h * 33 + c */
    }
    return (int)(h & 0x7fffffff);
}

/* Vulnerable function: uses gets-like behavior on a fixed stack buffer */
static int vulnerable_read(void) {
    char buf[64];
    int secret = 0x1337;

    puts("Enter a short message (max 200 chars):");
    /* intentionally unsafe read to create overflow for lab */
    if (!fgets(buf, 200, stdin)) return -1; /* fgets used with too-large size */

    printf("You typed: %s\n", buf);
    /* small decision: if payload contains "OVER", return 2 to change control flow */
    if (strstr(buf, "OVER")) return 2;
    /* Return whether the secret value was changed by exploitation */
    return (secret == 0x1337) ? 0 : 1;
}

/* Format-string-like vulnerability for analysis (no leaking by default) */
static void format_fun(const char *fmt) {
    char small[48];
    /* copy at most 47 chars, but still pass user data as fmt below */
    strncpy(small, fmt, sizeof(small)-1);
    small[sizeof(small)-1] = '\0';
    printf("Message: ");
    /* intentional flaw: untrusted string used as format specifier */
    printf(small);
    printf("\n");
}

/* Indirect call example: choose handler by hash */
static int handle_with_table(const char *input) {
    handler_t table[3] = {NULL, NULL, NULL};
    table[0] = (handler_t)printf; /* using printf as an example handler (casts) */
    table[1] = (handler_t)puts;
    table[2] = (handler_t)putchar; /* will be used in a weird way */

    int h = compute_hash(input);
    int idx = (h % 3);

    switch (idx) {
        case 0:
            /* printf-like: pass string
               note: casting is intentional to create odd calling convention for reverse */
            ((int(*)(const char *, ...))table[0])("handler0: %s\n", input);
            break;
        case 1:
            ((int(*)(const char *))table[1])("handler1 called");
            break;
        case 2:
            ((int(*)(int))table[2])(input[0]);
            break;
    }
    return idx;
}

/* A small "signature" computation that mixes bytes */
static uint32_t signature(const unsigned char *data, size_t n) {
    uint32_t s = 0xa5a5a5a5;
    for (size_t i = 0; i < n; ++i) {
        s ^= ((uint32_t)data[i] << ((i % 4) * 8));
        s = (s << 7) | (s >> (25));
        s += (uint32_t)i;
    }
    return s;
}

/* A function that hides a "correct" secret computed from input */
static int check_password(const char *pw) {
    if (!pw) return 0;
    char tmp[64];
    size_t L = strlen(pw);
    if (L > 60) return 0;
    memcpy(tmp, pw, L);
    tmp[L] = '\0';
    xor_transform(tmp, L, 0x5A);
    uint32_t sig = signature((unsigned char *)tmp, L);
    /* magic constant - if matched, grant access */
    if (sig == 0x1F2E3D4C) return 1;
    return 0;
}

int main(int argc, char **argv) {
    char input[128];
    banner();

    if (argc >= 2) {
        strncpy(input, argv[1], sizeof(input)-1);
        input[sizeof(input)-1] = '\0';
    } else {
        puts("Usage: lab02 <short-string>");
        puts("Then interactively enter data when prompted.");
        puts("Example: ./lab02 R3V_test");
        return 0;
    }

    int magic = check_magic(input);
    int flow = compute_hash(input) % 4;

    if (magic) {
        puts("Magic substring found â€” invoking check_password()...");
        if (check_password(input)) {
            puts("*** Access granted: secret unlocked ***");
            return 0;
        } else {
            puts("Password check failed.");
        }
    }

    switch (flow) {
        case 0:
            puts("Flow 0: simple handler");
            handle_with_table(input);
            break;
        case 1:
            puts("Flow 1: vulnerable read");
            vulnerable_read();
            break;
        case 2:
            puts("Flow 2: format fun (careful)");
            format_fun(input);
            break;
        case 3:
            puts("Flow 3: compute signature and show obfuscated result");
            {
                unsigned char buf[16];
                size_t L = strlen(input) < sizeof(buf) ? strlen(input) : sizeof(buf);
                memcpy(buf, input, L);
                uint32_t s = signature(buf, L);
                printf("sig=0x%08x\n", s);
            }
            break;
    }

    puts("Done.");
    return 0;
}