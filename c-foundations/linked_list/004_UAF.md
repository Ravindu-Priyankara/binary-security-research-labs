# Use After Free (UAF) Vulnerability: The Dangling Pointer

The **Use After Free (UAF)** vulnerability occurs when a program continues to use a **pointer** to access a block of memory *after* that memory block has been deallocated (`free()`d). The pointer that points to the freed memory is called a **dangling pointer**.

### 1\. How It Happens (The Mistake)

1.  **Allocation:** Memory is allocated for an object (e.g., `struct Node *ptr = malloc(sizeof(struct Node));`).

2.  **Deallocation (The Mistake):** The object is correctly deallocated (`free(ptr);`), but the pointer `ptr` is **not set to `NULL`**.

3.  **Vulnerability (The "Use"):** The code later uses the dangling pointer `ptr` (e.g., `ptr->method()` or `ptr->data = 5;`).

At this point, the memory management system (the heap) views the memory block as **free and available** for subsequent allocations, even though the program is still holding and potentially using the original pointer.

### 2\. Why It's Dangerous

The danger of UAF comes from the ability of an attacker to **repurpose** the freed memory block with a new, controlled object.

  * **The Reallocation:** The attacker triggers the program to allocate a new object (often one of the same size) which lands exactly in the memory space previously occupied by the freed object.

      * *Example:* If a freed linked list node is replaced by a malicious object the attacker controls (like a buffer filled with specific data).

  * **The Exploitation:** When the program uses the original dangling pointer to access the old object:

    1.  The program unknowingly accesses the data of the **new, attacker-controlled object**.

    2.  If the freed object contained **function pointers** (common in C++ objects or C structs used for polymorphism), the attacker can fill that memory with the address of their **shellcode** or a ROP gadget.

    3.  When the program tries to call the old method (e.g., `ptr->vtable_entry()`), it instead jumps to the address controlled by the attacker, hijacking the program's execution flow.

### 3\. Mitigation and Defensive Programming

Defending against UAF focuses on eliminating dangling pointers and using memory safety features:

  * **Nullify Pointers Immediately:** This is the most effective software-level defense. Always set the pointer to `NULL` after calling `free()`:

    ```c
    free(ptr);
    ptr = NULL; // Prevents subsequent use.
    ```

  * **Smart Pointers (C++):** In C++, using **smart pointers** (like `std::unique_ptr` or `std::shared_ptr`) automatically manages memory lifetimes, making manual `free()` calls and UAF vulnerabilities much less likely. When the last reference to an object is destroyed, the memory is automatically released.

  * **Garbage Collection Languages:** Languages with built-in garbage collection (like Python, Java, or Go) automatically reclaim unused memory, virtually eliminating UAF vulnerabilities.

  * **Hardened Heap Allocators:** Similar to the double free defense, modern allocators sometimes use techniques like **Delayed Freeing** or **Quarantine** to slightly delay the release of memory, which can sometimes detect and flag repeated use of a pointer to a recently freed block.

-----