# `fcn_append_pkg_extension` (`0x4035a0`)

## Purpose

Append the static file extension **`.pkg`** to an existing path string.

This function assumes the destination buffer already contains a valid
null-terminated base path.

---

## Inputs

* **`rdi`** → Destination buffer (pre-filled path)
* **`rsi`** → Source string (path to copy)

---

## Behavior

1. Copies the source string into the destination buffer using `stpcpy()`.
2. Writes the extension `.pkg` directly at the end of the copied string.
3. Appends a null terminator.

The extension is written inline using a 32-bit immediate value rather than a string literal.

---

## Reconstructed C Code

```c
void append_pkg_extension(char *dest, const char *src) {
    char *end = stpcpy(dest, src);
    *(uint32_t *)end = 0x676b702e; // ".pkg"
    end[4] = '\0';
}
```

---

## Output

* The destination buffer now contains:

```
<original_path>.pkg
```

---

## Analysis Notes

### Why malware constructs extensions this way

* Avoids storing `.pkg` as a static string
* Reduces signature-based detection
* Avoids `strcat()` and format functions
* Faster and stealthier than standard libc helpers

---

### Relationship to surrounding logic

This function is called immediately after resolving the executable path:

```
resolve_executable_path
   ↓
append ".pkg"
   ↓
open / validate archive
```

This strongly suggests the malware expects a **companion payload archive**
located alongside the executable.

---

### Indicator of packing / bundling behavior

Combined with:

* `_MEIPASS2` usage
* PATH resolution logic
* archive error messages

This behavior is consistent with **self-contained loaders** and
**PyInstaller-based malware stubs**.

---

## Appendix

<img src="./assets/fcn_append_pkg_extension_(0x4035a0).png" width="500">